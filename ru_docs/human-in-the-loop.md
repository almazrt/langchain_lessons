# Человек-в-цикле

Промежуточное ПО [Человек-в-цикле](/oss/python/langchain/middleware/built-in#human-in-the-loop) (HITL) позволяет добавить человеческий контроль к вызовам инструментов агента.
Когда модель предлагает действие, которое может потребовать проверки — например, запись в файл или выполнение SQL — промежуточное ПО может приостановить выполнение и дождаться решения.

Оно делает это, проверяя каждый вызов инструмента на соответствие настраиваемой политике. Если требуется вмешательство, промежуточное ПО выдает [прерывание](https://reference.langchain.com/python/langgraph/types/#langgraph.types.interrupt), которое останавливает выполнение. Состояние графа сохраняется с помощью [уровня сохранения](/oss/python/langgraph/persistence) LangGraph, поэтому выполнение может безопасно приостановиться и возобновиться позже.

Затем человеческое решение определяет, что произойдет дальше: действие может быть одобрено как есть ([approve](ru)), изменено перед запуском ([edit](ru)) или отклонено с обратной связью ([reject](ru)).

## Типы решений при прерывании

[Промежуточное ПО](/oss/python/langchain/middleware/built-in#human-in-the-loop) определяет три встроенных способа, которыми человек может ответить на прерывание:

| Тип решения | Описание                                                               | Пример использования                                    |
| ------------- | ------------------------------------------------------------------------- | --------------------------------------------------- |
| ✅ `approve`   | Действие одобрено как есть и выполняется без изменений.                | Отправить черновик электронного письма точно как написано              |
| ✏️ `edit`     | Вызов инструмента выполняется с изменениями.                             | Изменить получателя перед отправкой электронного письма        |
| ❌ `reject`    | Вызов инструмента отклонен, с объяснением, добавленным к беседе. | Отклонить черновик электронного письма и объяснить, как его переписать |

Доступные типы решений для каждого инструмента зависят от политики, которую вы настраиваете в `interrupt_on`.
Когда несколько вызовов инструментов приостанавливаются одновременно, каждое действие требует отдельного решения.
Решения должны быть предоставлены в том же порядке, в котором действия появляются в запросе прерывания.

<Tip>
  При **редактировании** аргументов инструмента вносите изменения осторожно. Значительные изменения в оригинальных аргументах могут привести к тому, что модель переоценит свой подход и потенциально выполнит инструмент несколько раз или примет неожиданные действия.
</Tip>

## Настройка прерываний

Чтобы использовать HITL, добавьте [промежуточное ПО](/oss/python/langchain/middleware/built-in#human-in-the-loop) в список `middleware` агента при создании агента.

Вы настраиваете его с помощью сопоставления действий инструментов с типами решений, которые разрешены для каждого действия. Промежуточное ПО прервет выполнение, когда вызов инструмента совпадет с действием в сопоставлении.

```python  theme={null}
from langchain.agents import create_agent
from langchain.agents.middleware import HumanInTheLoopMiddleware # [!code highlight]
from langgraph.checkpoint.memory import InMemorySaver # [!code highlight]


agent = create_agent(
    model="gpt-4o",
    tools=[write_file_tool, execute_sql_tool, read_data_tool],
    middleware=[
        HumanInTheLoopMiddleware( # [!code highlight]
            interrupt_on={
                "write_file": True,  # Все решения (approve, edit, reject) разрешены
                "execute_sql": {"allowed_decisions": ["approve", "reject"]},  # Редактирование не разрешено
                # Безопасная операция, одобрение не требуется
                "read_data": False,
            },
            # Префикс для сообщений прерывания - комбинируется с именем инструмента и аргументами для формирования полного сообщения
            # например, "Выполнение инструмента ожидает одобрения: execute_sql с query='DELETE FROM...'"
            # Отдельные инструменты могут переопределить это, указав "description" в своей конфигурации прерывания
            description_prefix="Выполнение инструмента ожидает одобрения",
        ),
    ],
    # Человек-в-цикле требует контрольные точки для обработки прерываний.
    # В производстве используйте постоянный контрольный пункт, такой как AsyncPostgresSaver.
    checkpointer=InMemorySaver(),  # [!code highlight]
)
```

<Info>
  Вы должны настроить контрольную точку для сохранения состояния графа между прерываниями.
  В производстве используйте постоянную контрольную точку, такую как [`AsyncPostgresSaver`](https://reference.langchain.com/python/langgraph/checkpoints/#langgraph.checkpoint.postgres.aio.AsyncPostgresSaver). Для тестирования или прототипирования используйте [`InMemorySaver`](https://reference.langchain.com/python/langgraph/checkpoints/#langgraph.checkpoint.memory.InMemorySaver).

  При вызове агента передайте `config`, который включает **ID потока**, чтобы связать выполнение с потоком беседы.
  Смотрите [документацию по прерываниям LangGraph](/oss/python/langgraph/interrupts) для получения подробной информации.
</Info>

<Accordion title="Параметры конфигурации">
  <ParamField body="interrupt_on" type="dict" required>
    Сопоставление имен инструментов с конфигурациями одобрения. Значения могут быть `True` (прервать с конфигурацией по умолчанию), `False` (автоматическое одобрение) или объектом `InterruptOnConfig`.
  </ParamField>

  <ParamField body="description_prefix" type="string" default="Выполнение инструмента требует одобрения">
    Префикс для описаний запросов действий
  </ParamField>

  **Параметры `InterruptOnConfig`:**

  <ParamField body="allowed_decisions" type="list[string]">
    Список разрешенных решений: `'approve'`, `'edit'` или `'reject'`
  </ParamField>

  <ParamField body="description" type="string | callable">
    Статическая строка или вызываемая функция для пользовательского описания
  </ParamField>
</Accordion>

## Ответы на прерывания

Когда вы вызываете агента, он выполняется до завершения или возникновения прерывания. Прерывание срабатывает, когда вызов инструмента совпадает с политикой, которую вы настроили в `interrupt_on`. В этом случае результат вызова будет включать поле `__interrupt__` с действиями, требующими проверки. Затем вы можете представить эти действия рецензенту и возобновить выполнение после предоставления решений.

```python  theme={null}
from langgraph.types import Command

# Человек-в-цикле использует уровень сохранения LangGraph.
# Вы должны предоставить ID потока, чтобы связать выполнение с потоком беседы,
# чтобы беседа могла быть приостановлена и возобновлена (как это необходимо для человеческого обзора).
config = {"configurable": {"thread_id": "some_id"}} # [!code highlight]
# Запустите граф до возникновения прерывания.
result = agent.invoke(
    {
        "messages": [
            {
                "role": "user",
                "content": "Удалить старые записи из базы данных",
            }
        ]
    },
    config=config # [!code highlight]
)

# Прерывание содержит полный запрос HITL с action_requests и review_configs
print(result['__interrupt__'])
# > [
# >    Interrupt(
# >       value={
# >          'action_requests': [
# >             {
# >                'name': 'execute_sql',
# >                'arguments': {'query': 'DELETE FROM records WHERE created_at < NOW() - INTERVAL \'30 days\';'},
# >                'description': 'Выполнение инструмента ожидает одобрения\n\nИнструмент: execute_sql\nАргументы: {...}'
# >             }
# >          ],
# >          'review_configs': [
# >             {
# >                'action_name': 'execute_sql',
# >                'allowed_decisions': ['approve', 'reject']
# >             }
# >          ]
# >       }
# >    )
# > ]


# Возобновление с решением об одобрении
agent.invoke(
    Command( # [!code highlight]
        resume={"decisions": [{"type": "approve"}]}  # или "edit", "reject" [!code highlight]
    ), # [!code highlight]
    config=config # Тот же ID потока для возобновления приостановленной беседы
)
```

### Типы решений

<Tabs>
  <Tab title="✅ approve">
    Используйте `approve`, чтобы одобрить вызов инструмента как есть и выполнить его без изменений.

    ```python  theme={null}
    agent.invoke(
        Command(
            # Решения предоставляются в виде списка, по одному на каждое действие под проверкой.
            # Порядок решений должен соответствовать порядку действий
            # перечисленных в запросе `__interrupt__`.
            resume={
                "decisions": [
                    {
                        "type": "approve",
                    }
                ]
            }
        ),
        config=config  # Тот же ID потока для возобновления приостановленной беседы
    )
    ```
  </Tab>

  <Tab title="✏️ edit">
    Используйте `edit`, чтобы изменить вызов инструмента перед выполнением.
    Предоставьте отредактированное действие с новым именем инструмента и аргументами.

    ```python  theme={null}
    agent.invoke(
        Command(
            # Решения предоставляются в виде списка, по одному на каждое действие под проверкой.
            # Порядок решений должен соответствовать порядку действий
            # перечисленных в запросе `__interrupt__`.
            resume={
                "decisions": [
                    {
                        "type": "edit",
                        # Отредактированное действие с именем инструмента и аргументами
                        "edited_action": {
                            # Имя инструмента для вызова.
                            # Обычно будет таким же, как и у оригинального действия.
                            "name": "new_tool_name",
                            # Аргументы для передачи инструменту.
                            "args": {"key1": "new_value", "key2": "original_value"},
                        }
                    }
                ]
            }
        ),
        config=config  # Тот же ID потока для возобновления приостановленной беседы
    )
    ```

    <Tip>
      При **редактировании** аргументов инструмента вносите изменения осторожно. Значительные изменения в оригинальных аргументах могут привести к тому, что модель переоценит свой подход и потенциально выполнит инструмент несколько раз или примет неожиданные действия.
    </Tip>
  </Tab>

  <Tab title="❌ reject">
    Используйте `reject`, чтобы отклонить вызов инструмента и вместо этого предоставить обратную связь.

    ```python  theme={null}
    agent.invoke(
        Command(
            # Решения предоставляются в виде списка, по одному на каждое действие под проверкой.
            # Порядок решений должен соответствовать порядку действий
            # перечисленных в запросе `__interrupt__`.
            resume={
                "decisions": [
                    {
                        "type": "reject",
                        # Объяснение о том, почему действие было отклонено
                        "message": "Нет, это неправильно, потому что ..., вместо этого сделайте это ...",
                    }
                ]
            }
        ),
        config=config  # Тот же ID потока для возобновления приостановленной беседы
    )
    ```

    `message` добавляется к беседе как обратная связь, чтобы помочь агенту понять, почему действие было отклонено и что он должен делать вместо этого.

    ***

    ### Множественные решения

    Когда несколько действий находятся на проверке, предоставьте решение для каждого действия в том же порядке, в котором они появляются в прерывании:

    ```python  theme={null}
    {
        "decisions": [
            {"type": "approve"},
            {
                "type": "edit",
                "edited_action": {
                    "name": "tool_name",
                    "args": {"param": "new_value"}
                }
            },
            {
                "type": "reject",
                "message": "Это действие не разрешено"
            }
        ]
    }
    ```
  </Tab>
</Tabs>

## Жизненный цикл выполнения

Промежуточное ПО определяет хук `after_model`, который выполняется после того, как модель генерирует ответ, но до выполнения любых вызовов инструментов:

1. Агент вызывает модель для генерации ответа.
2. Промежуточное ПО проверяет ответ на наличие вызовов инструментов.
3. Если какие-либо вызовы требуют человеческого ввода, промежуточное ПО создает `HITLRequest` с `action_requests` и `review_configs` и вызывает [interrupt](https://reference.langchain.com/python/langgraph/types/#langgraph.types.interrupt).
4. Агент ждет человеческих решений.
5. На основе решений `HITLResponse` промежуточное ПО выполняет одобренные или отредактированные вызовы, синтезирует [ToolMessage](https://reference.langchain.com/python/langchain/messages/#langchain.messages.ToolMessage) для отклоненных вызовов и возобновляет выполнение.

## Пользовательская логика HITL

Для более специализированных рабочих процессов вы можете создать пользовательскую логику HITL непосредственно с помощью примитива [interrupt](https://reference.langchain.com/python/langgraph/types/#langgraph.types.interrupt) и абстракции [промежуточного ПО](/oss/python/langchain/middleware).

Ознакомьтесь с [жизненным циклом выполнения](#жизненный-цикл-выполнения) выше, чтобы понять, как интегрировать прерывания в работу агента.

***
<Callout icon="pen-to-square" iconType="regular">
  [Редактировать источник этой страницы на GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/langchain/human-in-the-loop.mdx)
</Callout>

<Tip icon="terminal" iconType="regular">
  [Подключите эти документы программно](/use-these-docs) к Claude, VSCode и другим через MCP для получения ответов в реальном времени.
</Tip>

---
> Чтобы найти навигацию и другие страницы в этой документации, загрузите файл llms.txt по адресу: https://docs.langchain.com/llms.txt